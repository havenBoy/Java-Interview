### Synchronize

* 线程安全

  当多个线程访问一个对象或者方法时，这个对象可以表现出正确的行为时，称这个对象或者方法是线程安全的

* 使用方式

  - 同步普通方法，锁当前对象
  - 同步静态方法，锁当前class对象
  - 同步代码块，锁的是括号中的对象

* java内置锁

  线程在进入方法或者类时会自动获取锁，而在线程退出时会自动释放锁，这种锁是一个互斥锁，只有当前持有锁的线程退出时，下一个线程才能获取，如果当前线程不释放锁，那么下一个线程要获取就会进入阻塞队列

* 注意：

  - 这个关键字是不能继承的，也就是子类继承父类时，父类的Synchronize属性不能继承；
  - 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁；
  - 锁的内容应该尽量的短小，可以提高整体运行的效率；

* 实现原理；

  - 每一个对象都有一个监视器锁（monitor）,当此对象被占用时，计数器会进行加1；
  - 当相同的对象进入时，计数器再次加1，出去时调用monitorexit，计数器减1；
  - 当有其他线程想要进入时，发现计数器不为0，直到等待计数器为0时才能进入；

* **jdk1.5以后**

  - 此关键字得到了极大的优化，出现了偏向锁，轻量锁，自旋锁；

  - 每个java对象的头部信息中包含锁标志位，哈希码，GC分代年龄，当一个线程获取对象并加锁后，标志位由01变到10，其他的线程处于排队的状态；

  - **自旋锁**

    - 出现原因：线程在阻塞后进入排队队列与唤醒都需要CPU从用户态转到核心态，所以当有频繁的阻塞和唤醒需要大量的时间,代价较大；
    - 对于等待的线程，先不会加到等待队列，而是进行一个无意义的循环，直到运行到循环结束才会加入等待队列，这里的自选也是有范围的，因为自选本身也是消耗较大的；
    - 自适应自旋锁：动态调整自选上限次数

  - **轻量锁与 偏向锁**

    - 出现原因：同步的字段可能不存在竞争，所以还使用重量锁会消耗资源，注意：他俩使用的环境是在同步块无竞争时使用，如果出现竞争，还是会变回重量锁；

    - 使用环境：轻量锁是在多线程交替执行时同步块代码性能的提高，而偏向锁则是一个线程执行同步块时性能的提高；轻量锁获取或者释放锁时，需要依赖多次的CAS操作，而偏向锁只要一次的CAS原子指令，在置换ThreadID时；

    - 轻量锁（加锁过程）

      - 1.当代码进入同步块时，如果当前对象为无锁状态（锁标志位是01，偏向锁为0），虚拟机会在当前线程中复制出Lock Record区域，把当前对象的Mark Word复制出来
      - 2.拷贝成功后，虚拟机尝试使用CAS把Mark Word更新为指向Lock Record的指针，如果更新成功，那么进行下一步骤，否则继续执行此步骤
      - 3.进入此步骤，线程就拥有了此对象的锁，锁的标志位修改为00，表示这个对象处于轻量级锁；
      - 4.如果更新失败，即当前线程已经拥有该对象的锁，可以直接进入线程，如果是其他线程，那么就出现了多线程的竞争，那么轻量锁会变为重量锁，锁标志位变为10

    - 轻量锁解锁

      - 1.通过CAS操作尝试把当前的Lock Record 空间替换为当前的Mark Word；
      - 2.替换成功的话，同步过程完成；
      - 3.如果失败，说明此对象锁已经变成重量级锁，在释放锁的同时，会唤醒被挂起的线程；

    - 偏向锁（加锁过程）

      - 1.首先确认锁标标识是否是1，锁标志位是否为01；
      - 2.如果确认当前锁是偏向锁，那么测试当前线程ID是否指向当前线程，如果成功，那么执行；
      - 3.如果是不成功，通过CAS竞争锁，竞争成功后，把对象头线程ID设置为当前线程ID值，后执行同步代码块；
      - 4.如果偏向锁竞争失败，代表是有竞争的，偏向锁升级为重量锁；

    - 偏向锁（解锁）

      - 在其他线程尝试获取偏向锁时，持有偏向锁的对象才会释放，否则线程是不会主动释放偏向锁，

    - 锁粗化

      - 把多个连接在一起的加锁或者解锁合并为1次，把多个连续的锁扩展成一个范围更大的锁；
      - 例如；StringBUffer 对象的append()操作，之前是每一步的append操作都会进行一次加锁，

      ​        优化后，是把所有的append操作合并为一个锁进行执行；

    - 锁消除

      - 删除不必要的加锁操作；

  ### **volatile**

  - 操作变量时，会先把数据从主内存读取到自己本地的内存空间；
  - 在进行修改过后会把这个变量后，在合适的时间会把变量重新刷新到主内存中；
  - 关键字保证的是比变量在多个线程之间的可见性；
  - 但保证不了线程的安全性，比如++操作是非原子性的，数据可能在任何的一个阶段变化；

* 二者的比较

  需要围绕原子性和可见性；

  - volatile是轻量级的，只能修饰变量，synchronize是重量级的，可修饰方法和类；
  - volatile只能保证数据的可见性，并不能保证数据线程安全性，synchronize具有原子性，如果有多个线程访问会发生阻塞；