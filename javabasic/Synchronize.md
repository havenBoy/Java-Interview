### Synchronize

* 线程安全

  当多个线程访问一个对象或者方法时，这个对象可以表现出正确的行为时，称这个对象或者方法是线程安全的

* 使用方式

  - 同步普通方法，锁当前对象
  - 同步静态方法，锁当前class对象
  - 同步代码块，锁的是括号中的对象

* java内置锁

  线程在进入方法或者类时会自动获取锁，而在线程退出时会自动释放锁，这种锁是一个互斥锁，只有当前持有锁的线程退出时，下一个线程才能获取，如果当前线程不释放锁，那么下一个线程要获取就会进入阻塞队列

* 注意：

  - 这个关键字是不能继承的，也就是子类继承父类时，父类的Synchronize属性不能继承；
  - 实现同步是要很大的系统开销作为代价的，甚至可能造成死锁；
  - 锁的内容应该尽量的短小，可以提高整体运行的效率；

* 实现原理；

  - 每一个对象都有一个监视器锁（monitor）,当此对象被占用时，计数器会进行加1；
  - 当相同的对象进入时，计数器再次加1，出去时调用monitorexit，计数器减1；
  - 当有其他线程想要进入时，发现计数器不为0，直到等待计数器为0时才能进入；

  ### **volatile**

  - 操作变量时，会先把数据从主内存读取到自己本地的内存空间；
  - 在进行修改过后会把这个变量后，在合适的时间会把变量重新刷新到主内存中；
  - 关键字保证的是比变量在多个线程之间的可见性；
  - 但保证不了线程的安全性，比如++操作是非原子性的，数据可能在任何的一个阶段变化；

* 二者的比较

  需要围绕原子性和可见性；

  - volatile是轻量级的，只能修饰变量，synchronize是重量级的，可修饰方法和类；
  - volatile只能保证数据的可见性，并不能保证数据线程安全性，synchronize具有原子性，如果有多个线程访问会发生阻塞；