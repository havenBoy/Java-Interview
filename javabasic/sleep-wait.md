### 多线程常用方法

- sleep()

  当前线程暂停执行一段时间，让出CPU占用，让其他的线程执行，但是不会释放锁，即其他的线程仍然不能访问同步块的数据，该方法需要捕捉异常；它是Thread类的静态方法，可以指定具体暂停的时间；

- wait()，notify(), notifyall()

  三个都是java.lang.Object的方法，必须要在synchronize块中使用，使得当前线程虽然没有退出线程即可释放出机会让其他线程访问共享的数据，把当前线程放在对象等待池中，wait()方法会释放对象锁，而notify()方法则是从对象等待池中任意一个线程放在锁标志等待池中，即此时的线程才可以有机会去争夺锁，重新进入运行，而notifyall()方法会把所有等待的线程全部释放出去到锁等待池中；

- join()

  调用此方法的线程在此之前执行，也就是需要等待此方法执行以后才可执行，注意需要捕获异常；

  如：在t1中调用t2.join()方法，那么t1需要等待t2执行完成才可执行；

- yield()

  与sleep方法类似，只是不能指定暂停的时间，并且在此线程暂停后，只有同优先级或者比当前线程优先级高的处于就绪的线程可以抢占；它也是Thread类的静态方法；

- interrupt()

  给线程设置一个中断的标志，设置为true，并不会直接中断线程；调用此方法后，需要根据线程的状态来执行

  1.处于非阻塞状态，在调用此方法后，如果一旦调用sleep(),join()方法，会抛出InterruptedException，且中断标志清除；

  2.处于阻塞状态：根据中断标志的具体值，来决定如何退出线程；