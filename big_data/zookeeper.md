## zookeeper
> 一个分布式应用程序协调服务，实现分布式锁以及配置维护、同步
> 为服务提供集群管理，命名管理，队列管理
>
> 目的是为了减轻分布式应用程序所承担的协调任务，监视着集群中各个节点状态，根据节点的反馈进行下一步合理的操作，提供服务的主要三大神器：数据结构Znode+原语+watcher机制

- **一个新的数据结构（Znode）**
  它是一个层次的命名空间，与标准的文件系统类型，树形层次结构，树中的每个节点被称为Znode； 
  树中的每个节点都可以拥有子节点，且路径是唯一的，不能被改变； 
  Znode具有文件与目录的两种特点，像文件一样维护元数据，数据以及时间戳等数据结构，也可以作为路径标识的一部分；  每个Znode是由三部分组成：  
  
    1. stat 状态信息，描述该Znode的版本，权限等信息  
    2. data 与该Znode关联的数据  
    3. children 该Znode下的子节点
  它关联的数据大部分是管理调度数据，比如分布式应用中的配置文件信息，状态信息，一般来说都是比较小的数据，通常以KB为单位，且Zk会严格检查每个Znode的数据最多1M，常规要远低于此值；
  每个节点存储的数据要被原子性的操作，每个节点都拥有自己的访问控制权限，规定了用户的权限，即特定的用户对目标节点才能进行操作；
  节点类型：永久节点与临时节点，节点的类型在创建的时候确定，且不能被修改  
  - 永久节点：生命周期依赖于会话，结束后，临时节点就会被删除，临时节点不能拥有子节点
  - 临时节点：只有在客户端显式执行删除操作时才会被删除
  客户端在节点上设置watch，称为监视器，当节点状态发生改变时，会触发watch对应的操作，在watch触发时，会向客户端发送一条通知，触发操作只能触发一次；
- **zk中的时间**
  zxid是一个事务编号，zk中集群内部的所有事务都有一个全局唯一的顺序编号
  节点状态修改时都会收到一个Zxid格式的时间戳，且这个时间戳全局有序，需要了解以下三个：  
  
  1. cZxid  节点创建时间对应的Zxid格式的时间戳  
  2. mZxid  是该节点修改时间对应的Zxid格式的时间戳  
  3. pZxid  是该节点的子节点最近一次创建或者删除的对应时间戳
  对节点的每一个操作都会使得整个节点的版本号增加，每个节点维护着三个版本号，分别为  
  1. version  此节点的版本号
  2. cverison  子节点的版本号
  3. aversion  节点所拥有的访问权限控制的版本号
- **节点属性**
  
  1. czxid 节点被创建的zxid
  2. mzxid 节点被修改的zxid
  3. ctime 节点被创建的时间
  4. Mtime 节点被修改的时间
  5. version  节点被修改的版本号
  6. cversion 节点所拥有子节点被修改的版本号
  7. aversion  节点的ACL被修改的版本号
  8. ephemeralOwner 如果此节点为临时节点，那么值为演绎着会话的Id，否则为0
  9. dataLength 节点数长度 
- **操作类型**
  
  - create  创建Znode
  - delete  删除Znode  当前节点中没有子节点
  - exist   测试Znode是否存在，并获取其元数据
  - getACL/setACL 为该Znode获取或者设置其访问控制权限
  - getchildren  获取到该节点的子节点的列表
  - getData/setData 获取或者设置该节点的相关数据  
  - SYNC  将客户端的Znode视图与Zk同步  
- **监听机制**
  
  1. 概述： 
  为所有的读操作设置watch，这些读操作包括exist、getchildren、以及getData，是一个一次性触发机制，当监控的对象发生变化时，会触发所对应的事件，事件会被异步发送给客户端
  2. watch类型  
    -  数据监控  getData  exist
    -  孩子监控  getChildren
- zk**脑裂问题**
  - 描述：假死会导致脑裂，由于网络问题导致认为leader死了，但leader还在活着，所以发起信新的leader选举，但就leader的网络恢复后，出现了2个leader  
  - 解决方法：
    1. 默认方式，当前可以容忍的节点失效，必须要大于半数才会发起leader选举，例如3台服务器，那么可容忍1台机器挂掉.
    2. 冗余通信：集群中采用多种通信方式，防止一种通信方式失效导致集群中的节点无法通信
    3. 共享资源方式：能够获取到资源的锁即代表当前leader并没有失效
- **监听工作原理**
  watcher机制主要包括客户端进程、客户端WatcherManager,zookeeper服务器三部分
  客户端在向服务器注册同时，会将wathcer对象存储在客户端的watchManager中，当触发时，会向客户端发送通知，客户端的线程会从WatchManager中获取出对应的Watcher对象来执行回调函数
- **安装部署**
  
  - 主要配置参数在zoo.cfg
    1. tickTime  心跳的基本单位，毫秒级
    2. initLimit   代表心跳单位的个数，表示从leader选举结束后，主从通信需要的初始化时间
    3. syncLimit  表示tickTime的个数，表示follower和leader同步需要的最大等待时间
    4. dataDir  内存数据库快照存放地址
    5. clientPort  配置ZK监听客户端连接的端口
    6. dataLogDir  事务日志存储路径
    7. server.serverid = host:tickport:electionport  主机名：心跳通信端口：选举端口
- zk**中的角色**
  - leader  领导者进行投票的发起与决议，更新系统的状态
  - follower  用于接收客户请求并向客户端返回结果，在选举过程中参与投票
  - observer  可以接受客户端的连接，将写请求转发leader
  - client  请求发起方
- **常用的命令**
  
  - ls  /  
  
    查看当前zk中所包含的内容
  
  - create -s /aa "aa"  
  
    创建带编号的持久性节点“aa”
  
  - create -e /bb "bb" 
  
    创建不带编号的临时节点“bb”  如果需要带编号 -s -e
  
  - set /aa 
  
    设置aa节点内容   haha
  
  - get /aa
  
    获取aa节点内容
  
  - delete /aa
  
    删除aa目录节点
  
  - stat /aa  
  
    查看一个文件的状态信息
- zk**的典型应用场景**
  - 命名服务  在分布式环境中，zk可以实现一个分布式全局唯一ID的分配机制
  - 配置管理  把配置信息存储在zk的某个目录下，所有的应用程序对这个目录节点进行监听，一旦发生变化，每个应用程序会收到通知，然后从zk中获取最新的配置信息应用到系统中
  - 集群管理  主要分为集群中节点的增加与减少以及master的选举
  - 分布式锁  
  1. 写锁，对写加锁，保持独占，所有的客户端尝试创建节点，成功创建的客户端拥有锁，当使用完毕后，进行文件的删除，释放锁
  2. 读锁，对读加锁，释放锁后才可进行事务处理，是共享锁，锁已经存在，尝试在下面创建临时节点，编号最小的获取到锁，使用完毕删除，依次有序
- **paxos算法（ZAB协议）**
  基于消息传递，具有高度容错特性的一致性算法  
- **选举机制**
  - 全新集群选主（5个节点）
    1. 服务1启动，发送的报文没有任何响应，此时处于LOOKING状态
    2. 服务2启动，服务Id值较大胜出，但由于没有超过半数，所以还是处于LOOKING状态
    3. 服务3启动，已经超过半数，所以三节点变成leader
    4. 服务4启动，由于已经选取了3节点，所以只能作为follower
    5. 同4
  - 非全新集群选主
    1. 逻辑时钟小的选举结果被忽略
    2. 统一逻辑时钟后，数据version大的胜出
    3. 数据version相同时，server id较大胜出