### GC算法，垃圾回收

> java的内存回收主要存在于java堆和方法区内

* **对象是否存活的判断**

  - 引用计数法

    每个对象都有一个引用计数的属性，每次新增一个引用时，计数器就会加1，引用释放时，计数器就会减一，

    当计数器的数字为0时，表示这个数据不被引用，表示就可以回收了，但是这种方法有一个问题，无法解决互相引用的问题，

  - 可达性分析

    从GC  roots开始，向下搜索，搜素所经过的路径为引用链，当一个对象到GC roots没有任何引用链时，证明这个对象是不可用的；

* **垃圾回收算法**

  - 标记-清除算法

    分为2个步骤，第一是标记，第二是回收，首先标记出所有需要回收的对象，之后回收已经被标记的对象，但是有几个缺点：

    - 效率问题，标记与回收的效率都不高

    - 空间问题，标记清除后会有大量的不连续空间，当需要存储一个占用内存空间时，会无法找到合适的空间来满足空间的分配，

      使得不得不触发一次垃圾回收；

  - 复制算法

    会将内存空间分为2个相同的空间，每次只使用其中的一个，如果一块内存已经用完，那么就把还活着的对象转移到另外一个空间中，

    之后把原来的空间清空，这种算法比较简单，只是会把内存的大小缩小为原来的一半；

  - 标记-整理算法

    根据老年代的特点，前一步骤和标记清除算法一致，后一步不是把可回收对象进行回收，而是把存活的对象都向一端移动，

    然后清理掉一端的内存；

  - 分代回收

    指的是针对不同的对象使用不同的回收算法，一般把java堆分为2种对象，一种是新生代，一种是老年代，
    
    新生代的特点是每次回收都会发现有大量的对象死亡，那么使用复制算法，老年代因为对象的存活率较高，
    
    所以采用标记清除或者标记压缩进行回收；

* **垃圾回收器**

  - Serial收集器

    它是最古老，最稳定，效率最高的收集器，只能使用一个线程去回收，垃圾回收时会有较长时间的停顿；

  - Parallel收集器

    它关注系统的吞吐量，会通过监视系统的当前运行情况，动态调整回收的参数，使得系统能够获得最大的吞吐量和最小的停顿时间；

  - parallel old 收集器

    是对于parallel老年代版本；

  - CMS收集器

    主要的目的是获取最短的停顿时间为目的，主要分为4个步骤：

    - 初始标记    简单的标记从GCroots可以关联到的对象，速度很快，需要停顿；
    - 并发标记    回溯简单标记中的节点；
    - 重新标记   是为了在并发标记期间产生变化的对象，时间要比并发标记要少很多；
    - 并发清除   并发的对已经标记的对象进行清除；

    优点：停顿时间短，并发收集

    确定：产生大量的碎片，并发处理时，停顿的时间较长；

  - G1收集器

    主要目的是获取较短的时间停顿与保持较高的吞吐量

    - 使用标记整理算法，不会产生碎片；
    - 可预测停顿：它除了追求低停顿时间外，还允许建立可预测的停顿时间段；
    - 收集的步骤：
      - 标记阶段：初始标记，会触发一次minor GC；
      - 回收survivor区中的内容；
      - 并发标记，标记出不存活的对象，计算存活对象的比例；
      - 重新标记，也是为了在并发标记中，产生变化对象；
      - 并发清除，多线程清除已死对象；
      - 最后把还存活的新生代使用标记整理的方式存放在内存中，老年代对象不变；

* **那些对象可以被当做GC ROOT？**

  - 栈帧中存在的引用对象
  - 方法区静态属性的对象
  - 方法区常量引用对象
  - native方法中引用的对象，也是本地方法栈中